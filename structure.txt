MUST IMPLEMENTED:

MATRIX:
- 8x8 --> s(8x1), s(5x1) s(3x1)*2, s(1x1)*4
- 16x16 --> s(8x1)*2, s(5x1)*2, s(3x1)*4, s(1x1)*4
- 32x32 --> s(8x1)*4, s(5x1)*4, s(3x1)*5, s(1x1)*4


0. PLAY GAME
- User selects the board in the game and wait for an adversary.
- Adversary selects from a list the game already created or can create another game.
- ALL GAMES CREATED ARE DISPLAYED IN A LIST WITH CHARACTERISTIC (size of matrix).
- Once a game is selected, it disappears from the list.
- HANDLE GAMES SIMULTANEOUSLY.

	FUNCTIONS:
	1) createGame -->SM sets unique ID.
	2) joinGameRandom -->SM selects randomly the game. + EMIT EVENT START_GAME
	3) joinGameId -->Using the unique ID. + EMIT EVENT START_GAME
	4) agreementDeposit -->one propose and the other confirm or repropose the amount of ether)

	x)transferEthers

InfoGame(CREATOR_ADDR, PLAYER_ADDR, GAME_PHASE[who_played, numShipd_P1, numShip_P2], merkleRoot_P1, merkleRoot_P2, BOARD, DEPOSIT, ACCUSER)


1. PLACEMENT PHASE
- Users must insert ALL their ships on the matrix.

---------- implementation
- MERKLE TRIE + storing in the smart contract the ROOT MERKLE for P1 and P2.
(N x N board --> one leaf each cell with this value equal to H(state||random salt), salt different for each cell.State equal to 1 if there is a ship or 0.

	FUNCTIONS:
	1) submitMerkleRoot
	


2. SHOOTING PHASE
- Following turns, one user at time selects coordinates of one cell and tells the choice to him opponent.
- Opponent responds with "HIT" or "MISS"
- A ship is "SUNK" when all cells are hitted.

---------implementation
- SM stores target coordinates of attacker --> receiver reads SM coordinates --> send to SM (hit/miss, Merkle proof) --> SC verify the response --> if true it stores response in the game status
- SC game_state = numShips_P1, numShips_P2. (Counters decrease when hit).


	FUNCTIONS:
	1) submitTorpedo --> emit torpedoshot
	2) verifyResult --> emit something

	x) updateState




3. DECLARING WINNER
When a player hits all coordinates with ships, he is the winner.

---------implementation
- SC at the end of every turn check the winner condition --> if it is true, SC send to the winner a message --> transfer the amount of ether to all two players.

	FUNCTIONS:
	1) checkWinner

	x)transferEthers





4. PENALTY MECHANISM
Each player can accuse the other of having left the game.


--------imlementation
- Player_1 accuses Player_2 of having left the game --> SC emits an event and within 5 blocks the accused must make a guess --> if this is not the case, al the amount of ethers is sent to the accuser.

	FUNCTIONS:
	1)submitAccuse

	x)transferEthers